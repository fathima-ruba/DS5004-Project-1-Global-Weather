# -*- coding: utf-8 -*-
"""DS_Lab_Group_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eVG9p_8yRz4eTg76QCOkstUCRoofnA0m

# Introduction

*   Our data spans 22 days, capturing a snapshot of **weather and air quality conditions** throughout this period.
*   We have at our disposal a dataset consisting of a staggering **4,287 rows**.
*   These records encompass information from a total of **197 unique locations (Cities )**, scattered across **185 countries**.
"""

# Importing libraries

import numpy as np
import pandas as pd
import datetime
import missingno

import seaborn as sns
import matplotlib.pyplot as plt
import plotly.io as pio
import plotly.express as px
import plotly.figure_factory as ff
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from ipywidgets import widgets
import scipy.stats as stats

import os
from google.colab import files
from google.colab import output
output.enable_custom_widget_manager()

# Upload dataset to Colab workspace
uploaded = files.upload()

os.getcwd()

os.listdir()

#!rm 'GlobalWeather.csv'

"""## Importing and exploring the dataset"""

# Import the dataset into a DataFrame

global_weather = pd.read_csv('GlobalWeather.csv')
global_weather.head()

global_weather.shape

columns = global_weather.columns.values
columns

"""## Data cleaning

### Renaming columns
"""

global_weather.rename({col: col.partition('air_quality_')[2] for col in global_weather.iloc[:, 27:35].columns}, axis = 1, inplace = True)
global_weather.columns

"""### Checking for duplicates"""

global_weather.duplicated().sum()

# Observation - Since the number returned is zero, it implies that every row in our dataset is unique.

"""### Checking for incorrectly listed entries"""

global_weather.info()

global_weather.describe(include="object")

moonrise_bool = global_weather['moonrise'].str.contains('No moonrise')
moonrise_bool

moonrise_bool.any()                                               # Returns True if there is at least one True in the Series
                                                                        # True => there exists at least 1 occurence of 'No moonrise'

moonrise_bool.sum()                                               # Number of occurences of 'No moonrise'

moonrise_bool[moonrise_bool].index                                # Positions of occurences of 'No moonrise'

# Changing the data type of the objects to appropriate data types

global_weather['country'] = global_weather['country'].astype('category')
global_weather['location_name'] = global_weather['location_name'].astype('category')
global_weather['timezone'] = global_weather['timezone'].astype('category')
global_weather['condition_text'] = global_weather['condition_text'].astype('category')
global_weather['moon_phase'] = global_weather['moon_phase'].astype('category')

global_weather['last_updated_epoch'] = pd.to_datetime(global_weather['last_updated_epoch'], unit='s', utc=True)
                                                            # converting the epoch to a datetime by calculating the number of seconds since 1/1/1970
global_weather['last_updated'] = pd.to_datetime(global_weather['last_updated'])

global_weather['sunrise'] = pd.to_datetime(global_weather['sunrise'], format='%I:%M %p').dt.time
global_weather['sunset'] = pd.to_datetime(global_weather['sunset'], format='%I:%M %p').dt.time
global_weather['moonrise'] = pd.to_datetime(global_weather['moonrise'], format='%I:%M %p', errors='coerce').dt.time
global_weather['moonset'] = pd.to_datetime(global_weather['moonset'], format='%I:%M %p').dt.time


global_weather.dtypes

global_weather['sunrise'].iloc[0]

global_weather['moonrise'].iloc[0]

global_weather.head()

"""### Checking for missing data"""

global_weather.isna().sum()

# Observation - There are no NaN values
# 'No Moonrise' has been converted to NaT...... NaT represents missing or invalid values in datetime data

# Visual representation of the missing data in the dataset

missingno.matrix(global_weather)

"""## Statistical Analysis"""

glb_weather = global_weather.loc[:, ~global_weather.columns.isin(['temperature_fahrenheit', 'wind_mph', 'pressure_in', 'precip_in', 'feels_like_fahrenheit', 'visibility_miles', 'gust_mph'])]
glb_weather.columns

global_weather.describe()

global_weather.describe(include=['category', 'object'])

all_corr = glb_weather.corr()
all_corr

fig = px.imshow(all_corr, text_auto=True, aspect="auto", color_continuous_scale = 'Viridis', width=2000, height=1400)
fig.update_xaxes(side="top")

fig.show()

# Plotting only the significant correlation

fig = px.imshow(all_corr[(all_corr >= 0.5) |(all_corr <= -0.35)], text_auto=True, aspect="auto", color_continuous_scale = 'Cividis_r', width=1200, height=800)
fig.update_xaxes(side="top")
fig.show()

"""## Exploratory data analysis

### Feature Analysis - Univariate Analysis
"""

def plot_box_hist(col1, col2, nbins, title):
  fig = make_subplots(rows=2, cols=2)

  trace0 = go.Box(y  = global_weather[col1], name = col1)
  trace1 = go.Box(y = global_weather[col2], name = col2)
  trace2 = go.Histogram(x  = global_weather[col1], name = col1, nbinsx = nbins)
  trace3 = go.Histogram(x = global_weather[col2], name = col2, nbinsx = nbins)

  fig.add_trace(trace0, row=1, col=1)
  fig.add_trace(trace1, row=1, col=2)
  fig.add_trace(trace2, row=2, col=1)
  fig.add_trace(trace3, row=2, col=2)

  fig.update_layout(height=800, width=1200, title_text=title, showlegend=True)
  fig.show()

print('Number of Weather condition types: ', len(global_weather['condition_text'].unique()), '\n')
global_weather['condition_text'].value_counts()

print('Number of distinct wind directions: ', len(global_weather['wind_direction'].unique()), '\n')
global_weather['wind_direction'].value_counts()

print('Number of distinct moon illumination values: ', global_weather['moon_illumination'].unique())

plot_box_hist('temperature_celsius', 'feels_like_celsius', 50, 'Temperature & Feel temperature in Celsius')

plot_box_hist('temperature_fahrenheit', 'feels_like_fahrenheit', 50, 'Temperature & Feel temperature in Fahrenheit')

plot_box_hist('wind_mph', 'wind_kph', 20, 'Wind speed in mph and kph')

plot_box_hist('pressure_mb', 'pressure_in', 20, 'Presssure in millibars and inches')

plot_box_hist('precip_mm', 'precip_in', 50, 'Precipitation in mm and inches')

plot_box_hist('visibility_km', 'visibility_miles', 12, 'Visibility in km and miles')

px.box(global_weather, y = 'humidity')

px.histogram(global_weather, 'humidity', nbins = 20)

plot_box_hist('gust_mph', 'gust_kph', 12, 'Wind gust in mph and kph')

fig = make_subplots(rows=4, cols=2)

trace0 = go.Histogram(x  = global_weather['Carbon_Monoxide'], name = 'Carbon_Monoxide', nbinsx = 30)
trace1 = go.Histogram(x  = global_weather['Ozone'], name = 'Ozone')
trace2 = go.Histogram(x  = global_weather['Nitrogen_dioxide'], name = 'Nitrogen_dioxide', nbinsx = 30)
trace3 = go.Histogram(x = global_weather['Sulphur_dioxide'], name = 'Sulphur_dioxide', nbinsx = 30)
trace4 = go.Histogram(x = global_weather['PM2.5'], name = 'PM2.5', nbinsx = 30)
trace5 = go.Histogram(x  = global_weather['PM10'], name = 'PM10', nbinsx = 30)
trace6 = go.Histogram(x = global_weather['us-epa-index'], name = 'us-epa-index')
trace7 = go.Histogram(x  = global_weather['gb-defra-index'], name = 'gb-defra-index')

fig.add_trace(trace0, row=1, col=1)
fig.add_trace(trace1, row=1, col=2)
fig.add_trace(trace2, row=2, col=1)
fig.add_trace(trace3, row=2, col=2)
fig.add_trace(trace4, row=3, col=1)
fig.add_trace(trace5, row=3, col=2)
fig.add_trace(trace6, row=4, col=1)
fig.add_trace(trace7, row=4, col=2)

fig.update_layout(height=800, width=1200, title_text='AQI measurements', showlegend=True)
fig.show()

"""### Feature Analysis - Bivariate Analysis"""

px.box(global_weather, x = 'condition_text', y = 'temperature_celsius')

px.box(global_weather, x = 'condition_text', y = 'feels_like_celsius')

px.box(global_weather, x = 'condition_text', y = 'humidity')

px.scatter(global_weather, x = 'temperature_celsius', y = 'humidity',
           marginal_x='histogram',
           marginal_y='rug')

condition_grps = glb_weather.groupby('condition_text')

#data = condition_grps['cloud'].mean()
data = condition_grps['cloud'].median()
data_sorted = data.sort_values(ascending=False)
px.bar(data_sorted, y = 'cloud', title = 'Median cloud cover as a percentage', color_discrete_sequence = px.colors.sequential.Plasma)

condition_grps = glb_weather.groupby('condition_text')
cloud_grp = condition_grps.get_group('Cloudy')
cloud_grp

# Group the moon phases and calculate the mean of moon illumination
glb_weather_moon = glb_weather.groupby('moon_phase')['moon_illumination'].agg(['mean']).reset_index()

glb_weather_moon = glb_weather_moon.rename(columns={'mean': 'moon_illumination'})
glb_weather_moon

fig = px.pie(
    glb_weather_moon,
    names='moon_phase',
    values='moon_illumination',
    title='Moon Phase and Moon Illumination',
    height=600,
    hole=0.4,
    labels=(
        {
            'moon_phase': 'Moon Phase',
            'moon_illumination': 'Moon Illumination (%)'
        }
    ),
)

fig.update_traces(textposition='inside', textinfo='label+percent')

fig.show()

"""### Feature Analysis - Multivariate Analysis"""

user_location = 'New Delhi'  # Change this into your desired location

# Filter dataframe for the desired location
location_df = glb_weather[glb_weather['location_name'] == user_location]

# Extracting wind df
wind_speeds = location_df['wind_kph']
wind_degrees = location_df['wind_degree']

# Converting wind degrees to radians
wind_radians = np.deg2rad(wind_degrees)

#rose wind plot

plt.figure(figsize=(8, 8))
ax = plt.subplot(111, polar=True)
n_bins = 16
hist, bins = np.histogram(wind_radians, bins=n_bins)

# width of each bin
width = 2 * np.pi / n_bins

# list of colors for each bin
colors = plt.cm.viridis(hist / hist.max())

# histogram as a bar plot with colors
bars = ax.bar(bins[:-1], hist, width=width, align="edge", color=colors)

# direction labels
ax.set_xticks(np.arange(0, 2 * np.pi, width))
ax.set_xticklabels(['NNW','NW','SE','NE','WSW','SW','N','WNW','ESE','S','E','ENE','SSW','W','SSE','NNE'])

#color bar legend
color_legend = plt.colorbar(plt.cm.ScalarMappable(cmap=plt.cm.viridis), ax=ax, pad=0.1)
color_legend.set_label('Wind Speed (kph)')

plt.title(f'Rose Wind Plot for {user_location}')
plt.show()

"""## Forecasting and Inferences

### Feature Engineering
"""

# Splitting the data based on climate zones

glb_weather.loc[(glb_weather['latitude'] < 23.5) & (glb_weather['latitude'] > -23.5), 'region'] = 'Tropical'
glb_weather.loc[((glb_weather['latitude'] >= 23.5) & (glb_weather['latitude'] <= 66.5)) | ((glb_weather['latitude'] <= -23.5) & (glb_weather['latitude'] >= -66.5)), 'region'] = 'Temperate'
glb_weather.loc[(glb_weather['latitude'] > 66.5) | (glb_weather['latitude'] < -66.5), 'region'] = 'Polar'

# counting unique 'location_name' values for each region

tropical_df = glb_weather[glb_weather['region'] == 'Tropical']
temperate_df = glb_weather[glb_weather['region'] == 'Temperate']
polar_df = glb_weather[glb_weather['region'] == 'Polar']

tropical_location_count = tropical_df['location_name'].nunique()
temperate_location_count = temperate_df['location_name'].nunique()
polar_location_count = polar_df['location_name'].nunique()


print("Total Locations in Tropical region:", tropical_location_count)
print("Total Locations in Temperate region:", temperate_location_count)
print("Total Locations in Polar region:", polar_location_count)

"""Observation - No data available from Polar region

### Temperature Trends
"""

city_country = {}

cities = global_weather['location_name'].unique()
for city in cities:
  city_first_index = global_weather[global_weather['location_name'] == city].index[0]
  city_country[city] = global_weather.loc[city_first_index, 'country']

city_country

global_country_grp_mean = glb_weather.groupby('country').mean().reset_index()
global_temp_mean = global_country_grp_mean.sort_values(by = 'temperature_celsius')
px.bar(global_temp_mean, x='country', y='temperature_celsius', color = 'temperature_celsius',
       color_discrete_sequence = px.colors.sequential.thermal,
       title='Average Temperature by Country')

global_city_grp_mean = glb_weather.groupby('location_name').mean().reset_index()
global_temp_mean = global_city_grp_mean.sort_values(by = 'temperature_celsius')

def create_bar_chart(data, title, color):
    fig = px.bar(data, x='location_name', y='temperature_celsius', title=title)
    fig.update_traces(marker_color=color, marker_line_color='black', marker_line_width=1)
    fig.update_xaxes(categoryorder='total ascending')
    return fig

coldest_chart_color = 'rgb(75, 136, 230)'  # Blue
hottest_chart_color = 'rgb(255, 87, 51)'  # Red

coldest_5_cities = global_temp_mean.iloc[:5, :]
hottest_5_cities = global_temp_mean.iloc[-5:, :]

hottest_bar_chart = create_bar_chart(hottest_5_cities.sort_values(by = 'temperature_celsius', ascending = False),
                                     'Top 5 Cities by Maximum Average Temperature', hottest_chart_color)
coldest_bar_chart = create_bar_chart(coldest_5_cities, 'Bottom 10 Cities by Minimum Average Temperature', coldest_chart_color)

fig = make_subplots(rows=1, cols=2, subplot_titles=('Coldest 5 Cities', 'Hottest 5 Cities'))
fig.add_trace(coldest_bar_chart.data[0], row=1, col=1)
fig.add_trace(hottest_bar_chart.data[0], row=1, col=2)

fig.show()

"""Mean Temperature(°C), Pressure(mb) and Humidity Data - Location Wise"""

grouped_data = glb_weather.groupby(['latitude', 'longitude'])[['temperature_celsius', 'pressure_mb', 'humidity']].mean().reset_index()

# Merging 'location_name' back to the grouped data
grouped_data = pd.merge(grouped_data, glb_weather[['latitude', 'longitude', 'location_name']], on=['latitude', 'longitude'], how='left')

# scatter plot with hover information
fig = px.scatter_geo(grouped_data,
                     lat='latitude',
                     lon='longitude',
                     hover_name='location_name',
                     hover_data=['temperature_celsius', 'pressure_mb', 'humidity'],
                     color='temperature_celsius',
                     labels={'temperature_celsius': 'Mean Temp (°C)',
                             'pressure_mb': 'Mean Pressure (mb)',
                             'humidity': 'Humidity'},
                     title='Mean Weather Data',
                     projection="natural earth")

fig.show()

aggs = ["count","sum","avg","median","mode","rms","stddev","min","max","first","last"]

agg = []
agg_func = []
for i in range(0, len(aggs)):
    agg = dict(
        args=['transforms[0].aggregations[0].func', aggs[i]],
        label=aggs[i],
        method='restyle'
    )
    agg_func.append(agg)

data = [dict(
  type = 'choropleth',
  locationmode = 'country names',
  locations = glb_weather['country'],
  z = glb_weather['temperature_celsius'],
  autocolorscale = False,
  colorscale = 'Viridis',
  reversescale = True,
  transforms = [dict(
    type = 'aggregate',
    groups = glb_weather['country'],
    aggregations = [dict(
        target = 'z', func = 'avg', enabled = True)
    ]
  )]
)]

layout = dict(
  title = '<b>Temperature (°C) Aggregations</b><br>use dropdown to change aggregation function',
  #xaxis = dict(title = 'Subject'),
  #yaxis = dict(title = 'Score', range = [0,22]),
  height = 600,
  width = 900,
  updatemenus = [dict(
        x = 1.05,
        y = 1.10,
        xref = 'paper',
        yref = 'paper',
        yanchor = 'top',
        active = 2,
        showactive = False,
        buttons = agg_func
  )]
)

fig_dict = dict(data=data, layout=layout)

pio.show(fig_dict, validate=False)

countries = glb_weather['country'].unique()
rand_country_list = np.random.choice(countries, 4)

temp_trend = glb_weather[glb_weather['country'].isin(rand_country_list)]
temp_trend_grp = temp_trend.groupby('country')

temp_trend.head(4)

fig = go.Figure()
colors = ['firebrick', 'rebeccapurple', 'royalblue', 'mediumseagreen']

for idx in range(4):
  country = rand_country_list[idx]
  rand_country_grp = temp_trend_grp.get_group(country)
  fig.add_trace(go.Scatter(x = rand_country_grp['last_updated'], y = rand_country_grp['temperature_celsius'],
                           mode='lines+markers',
                           name = country,
                           line=dict(color=colors[idx])))

fig.update_layout(title='Temperature Trends for randomly selected 4 cities',
                   xaxis_title='Last Updated',
                   yaxis_title='Temperature (°C)')
fig.show()

option_list = ['uv_index', 'wind_kph', 'Carbon_Monoxide', 'Ozone', 'Nitrogen_dioxide', 'Sulphur_dioxide', 'PM2.5', 'PM10']
option_val_tuple = list((k,v) for v, k in list(enumerate(option_list, 1)))
option_val_tuple

text_dict = {1: ['uv_index', 'UV index'],
             2: ['wind_kph', 'Wind Seepd in kph'],
             3: ['Carbon_Monoxide', 'Carbon monoxide'],
             4: ['Ozone', 'Ozone'],
             5: ['Nitrogen_dioxide', 'Nitrogen dioxide'],
             6: ['Sulphur_dioxide', 'Sulphur dioxide'],
             7: ['PM2.5', 'PM 2.5'],
             8: ['PM10', 'PM 10']}

pollutants = widgets.RadioButtons(
    options = option_val_tuple,
    value = 1,            # Default value
    disabled = False
)

# Assign an empty figure widget with two traces
min_value = min(global_country_grp_mean['uv_index'])      # Minimum mean value by country
max_value = max(global_country_grp_mean['uv_index'])
delta_value = global_country_grp_mean['uv_index'].mean()  # Mean value of parameter
text = 'UV index'

fw = go.FigureWidget({
    'data': [{'delta': {'reference': delta_value},
              'domain': {'x': [0, 1], 'y': [0, 1]},
              'gauge': {'axis': {'range': [None, 40]},
                        'bar': {'color': 'darkblue'},
                        'steps': [{'color': 'whitesmoke', 'range': [0, 10]},
                                  {'color': 'palegreen', 'range': [10, 20]},
                                  {'color': 'lightsalmon', 'range': [20, 30]},
                                  {'color': 'indianred', 'range': [30, 40]}]},
              'mode': 'gauge+number+delta',
              'title': {'text': 'UV index'},
              'type': 'indicator',
              'value': min_value}]})

def update_pollutant_widget(change):
  selected_option=pollutants.value
  selected_col = text_dict[selected_option][0]
  min_value = min(global_country_grp_mean[selected_col])    # Minimum mean value by country
  max_value = max(global_country_grp_mean[selected_col])    # Maximum mean value by country
  avg_value = global_country_grp_mean[selected_col].mean()  # Mean value of parameter
  text = text_dict[selected_option][1]
  with fw.batch_update():
    trace1 = fw.data[0]
    trace1.delta.reference = avg_value
    trace1.value = min_value
    trace1.title.text = text
    trace2 = fw.data[1]
    trace1.delta.reference = avg_value
    trace1.value = max_value
    trace1.title.text = text

pollutants.observe(update_pollutant_widget , names='value')

widgets.HBox([pollutants])

widgets.VBox([fw])

from google.colab import output
output.enable_custom_widget_manager()

"""Support for third party widgets will remain active for the duration of the session. To disable support:"""

from google.colab import output
output.disable_custom_widget_manager()

px.scatter(global_weather, x='temperature_celsius', y='humidity', color='country', title='Temperature vs Humidity', color_discrete_sequence = px.colors.diverging.delta)

px.scatter(global_weather, x = 'temperature_celsius', y = 'humidity',
           size='visibility_km',
           color='condition_text',
           facet_col = 'wind_direction',
           facet_col_wrap = 4)

"""### Precipitation Trends"""

px.scatter(global_weather, x='humidity', y='precip_mm', color='country', title='Humidity vs Precipitation in mm', color_discrete_sequence = px.colors.sequential.Teal)

"""Day Wise Percipitation (mm) - Taking Location as User Input"""

location_name = input('Please Enter the location name for check day wise Precipitation: ').strip().lower()

# Filtering the DataFrame for the specific location
location_data = glb_weather[glb_weather['location_name'].str.lower() == location_name]

if location_data.empty:
    print(f"No data found for the location '{location_name}'. Please check the spelling and try again.")

else:

    # Extracting the date part from the 'last_updated' column
    location_data['date'] = location_data['last_updated'].dt.date

    # total precipitation for each day
    daily_precipitation = location_data.groupby('date')['precip_mm'].sum()

    # bar plot for daily precipitation
    plt.figure(figsize=(12, 6))
    daily_precipitation.plot(kind='bar', color='skyblue')
    plt.title(f'Daily Precipitation for {location_name}')
    plt.xlabel('Date')
    plt.ylabel('Total Precipitation (mm)')
    plt.xticks(rotation=90)
    plt.tight_layout()
    plt.show()

"""## Geographical Trends

Distribution Comparison (Tropical vs Temperate)
"""

tropical_data = glb_weather[glb_weather['region'] == 'Tropical']
temperate_data = glb_weather[glb_weather['region'] == 'Temperate']

sns.set_style("whitegrid")

# 2 x 2 subplots
fig, axes = plt.subplots(2, 2, figsize=(12, 8))
fig.suptitle("Distribution Comparison ('Tropical' vs 'Temperate')")

# temperature_celsius distribution
sns.histplot(tropical_data['temperature_celsius'], ax=axes[0, 0], label='Tropical', kde=True, color='blue')
sns.histplot(temperate_data['temperature_celsius'], ax=axes[0, 0], label='Temperate', kde=True, color='orange')
axes[0, 0].set_title('Temperature (Celsius) Distribution')
axes[0, 0].set_xlabel('Temperature (Celsius)')
axes[0, 0].legend()

# pressure_mb distribution
sns.histplot(tropical_data['pressure_mb'], ax=axes[0, 1], label='Tropical', kde=True, color='blue')
sns.histplot(temperate_data['pressure_mb'], ax=axes[0, 1], label='Temperate', kde=True, color='orange')
axes[0, 1].set_title('Pressure (mb) Distribution')
axes[0, 1].set_xlabel('Pressure (mb)')
axes[0, 1].legend()

# wind_mph distribution
sns.histplot(tropical_data['wind_kph'], ax=axes[1, 0], label='Tropical', kde=True, color='blue')
sns.histplot(temperate_data['wind_kph'], ax=axes[1, 0], label='Temperate', kde=True, color='orange')
axes[1, 0].set_title('Wind Speed (kph) Distribution')
axes[1, 0].set_xlabel('Wind Speed (kph)')
axes[1, 0].legend()

# humidity distribution
sns.histplot(tropical_data['humidity'], ax=axes[1, 1], label='Tropical', kde=True, color='blue')
sns.histplot(temperate_data['humidity'], ax=axes[1, 1], label='Temperate', kde=True, color='orange')
axes[1, 1].set_title('Humidity Distribution')
axes[1, 1].set_xlabel('Humidity')
axes[1, 1].legend()

plt.tight_layout()
plt.subplots_adjust(top=0.9)
plt.show()

"""Co-Relation Heatmap for Tropical and Temperate Data"""

req_columns = ['temperature_celsius', 'wind_kph', 'pressure_mb', 'precip_mm', 'humidity', 'cloud', 'visibility_km', 'uv_index', 'gust_kph', 'Carbon_Monoxide', 'Ozone', 'Nitrogen_dioxide','Sulphur_dioxide', 'PM2.5', 'PM10']

def create_correlation_heatmap(data, title):
    correlation_matrix = data[req_columns].corr()
    plt.figure(figsize=(12, 10))
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
    plt.title(title)
    plt.show()

create_correlation_heatmap(tropical_data, "Correlation Heatmap - Tropical Region")
create_correlation_heatmap(temperate_data, "Correlation Heatmap - Temperate Region")

"""### AQI Trends

**For PM 2.5 index**
"""

# Using isin() method to drop multiple columns
pollutant_df = glb_weather.loc[:, ~glb_weather.columns.isin(['PM2.5', 'PM10', 'us-epa-index', 'gb-defra-index'])]
pollutant_df.columns

# Correlation using pairplot

pollutant_df_num = pollutant_df.select_dtypes(include = ['float64', 'int64'])

for i in range(0, len(pollutant_df_num.columns),5):
    sns.pairplot(pollutant_df_num, y_vars ='Carbon_Monoxide', x_vars = pollutant_df_num.columns[i:i+5])

"""Climate Zone vs Major Pollutant Level (Median)"""

glb_weather.rename(columns={
    'Carbon_Monoxide': 'Carbon Monoxide (CO)',
    'Ozone': 'Ozone (O3)',
    'Nitrogen_dioxide': 'Nitrogen Dioxide (NO2)',
    'Sulphur_dioxide': 'Sulphur Dioxide (SO2)',
    'PM2.5': 'PM2.5',
    'PM10': 'PM10'
}, inplace=True)

# Group and calculate medians
grouped_data = glb_weather.groupby('region').agg({
    'Carbon Monoxide (CO)': 'median',
    'Ozone (O3)': 'median',
    'Nitrogen Dioxide (NO2)': 'median',
    'Sulphur Dioxide (SO2)': 'median',
    'PM2.5': 'median',
    'PM10': 'median'
}).reset_index()

sns.set(style="whitegrid")

# subplots : 2 x 3
fig, axes = plt.subplots(2, 3, figsize=(18, 10))

# Bar charts for each air quality metric
metrics = ['Carbon Monoxide (CO)', 'Ozone (O3)', 'Nitrogen Dioxide (NO2)', 'Sulphur Dioxide (SO2)', 'PM2.5', 'PM10']

for i, metric in enumerate(metrics):
    row, col = divmod(i, 3)
    ax = axes[row, col]

    sns.barplot(data=grouped_data, x='region', y=metric, ax=ax)
    ax.set_title(f'Air Quality - {metric}',fontsize=16)
    ax.set_xlabel('')
    ax.set_ylabel(metric)
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')  # Rotate x-axis labels for better readability

plt.tight_layout()
plt.show()

"""*   Higher Air Pollution level in Temerate Zone : Typically, warm rising air near the ground lifts pollution away, but during the winter the layer of warm air acts like a lid, keeping cold air at the surface.

## Hypothesis Testing

**Hypothesis Test: Air quality between coastal and landlocked countries**
"""

coastal_countries = ['Australia', 'Brazil', 'Canada', 'China', 'France', 'Germany', 'India', 'Indonesia', 'Italy', 'Japan', 'Mexico', 'Russia', 'South Africa', 'Spain', 'United Kingdom', 'United States']
landlocked_countries = ['Afghanistan', 'Armenia', 'Austria', 'Belarus', 'Bolivia', 'Botswana', 'Burkina Faso', 'Hungary', 'Kazakhstan', 'Laos', 'Mali', 'Mongolia', 'Nepal', 'Paraguay', 'Rwanda', 'Switzerland', 'Uganda', 'Zimbabwe']

coastal_data = glb_weather[glb_weather['country'].isin(coastal_countries)]['PM2.5']
landlocked_data = glb_weather[glb_weather['country'].isin(landlocked_countries)]['PM2.5']

t_stat_air_quality, p_value_air_quality = stats.ttest_ind(coastal_data, landlocked_data)
t_stat_air_quality, p_value_air_quality

"""**Result:** Since the p-value is significantly smaller than 0.05, we reject the null hypothesis. This suggests that there is a statistically significant difference in air quality (PM2.5 levels) between coastal and landlocked countries

**Hypothesis test using the t-test and determine whether there is a significant difference in AQI values between the two groups**
"""

temperate_cntry_grp = temperate_data.groupby('country', as_index=False)
temperate_rand_country_list = np.random.choice(temperate_data['country'].unique(), 16)
sample1 = temperate_rand_country_list[:8]
sample2 = temperate_rand_country_list[8:]

group1 = pd.DataFrame()
group2 = pd.DataFrame()

for country in sample1:
  group_data = temperate_cntry_grp.get_group(country).reset_index()
  group1 = group1.append(group_data, ignore_index=True)

for country in sample2:
  group_data = temperate_cntry_grp.get_group(country).reset_index()
  group2 = group2.append(group_data, ignore_index=True)


# Separate the AQI data for the two groups
group1_aqi = group1['gb-defra-index']
group2_aqi = group2['gb-defra-index']

# Perform the t-test
t_stat, p_value = stats.ttest_ind(group1_aqi, group2_aqi)

# Print the results
print('T-statistic:', t_stat)
print('P-value:', p_value, '\n\n')

